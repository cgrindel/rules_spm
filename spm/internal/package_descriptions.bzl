"""\
Logic for parsing and retrieving information from package description 
JSON as generated by `swift package describe --type json`.\
"""

load("@bazel_skylib//lib:paths.bzl", "paths")
load("@bazel_skylib//lib:sets.bzl", "sets")
load(":packages.bzl", "packages")

# MARK: - Package Description JSON Retrieval

def _parse_json(json_str):
    """Parses the JSON string and returns a dict representing the JSON structure.

    Args:
        json: JSON string.

    Returns:
        A dict which contains the information from the JSON string.
    """
    return json.decode(json_str)

def _get_package_description(repository_ctx, working_directory = ""):
    """Returns a dict representing the package description for an SPM package.

    Args:
        repository_ctx: A `repository_ctx`.
        working_directory: A `string` specifying the directory for the SPM package.

    Returns:
        A `dict` representing an SPM package description.
    """
    describe_result = repository_ctx.execute(
        ["swift", "package", "describe", "--type", "json"],
        # ["swift", "package", "dump-package"],
        working_directory = working_directory,
    )
    return _parse_json(describe_result.stdout)

# MARK: - Product Functions

def _is_library_product(product):
    """Returns a boolean indicating whether the specified product dictionary
    is a library product.

    Args:
        product: A `dict` representing a product from package description
                 JSON.

    Returns:
        A `bool` indicating whether the product is a library.
    """
    return "library" in product["type"]

def _library_products(pkg_desc):
    """Returns the library products defined in the provided package 
    description.

    Args:
        pkg_desc: A `dict` representing a package description.

    Returns:
        A `list` of product `dict` values as defined in a package description.
    """
    return [p for p in pkg_desc["products"] if _is_library_product(p)]

# MARK: - Target Functions

def _gather_deps_for_targets(targets_dict, target_names):
    """Returns a set of target names that are dependencies of the specified
    target names.

    Args:
        target_dict: A `dict` of package description targets indexed by name.
        target_names: A `list` of target names for which the dependencies
                      should be gathered.

    Returns:
        A `set` (see `sets.make()`) of target names that are dependencies
        of the specified targets.
    """
    deps = sets.make()
    for name in target_names:
        target = targets_dict[name]
        target_deps = target.get("target_dependencies", default = [])
        deps = sets.union(deps, sets.make(target_deps))
    return deps

def _exported_library_targets(pkg_desc, product_names = None, with_deps = False):
    """Returns the exported targets from the SPM pacakge.

    If a list of product names is provided, only the targets associated with
    the specified products will be returned.

    If the dependencies are requested, the outputs will include all of the
    dependent targets as well as those referenced directly by the products.

    Args:
        pkg_desc: The dict returned from the `parse_package_descrition_json`.
        product_names: Optional. A `list` of product names (`string`) to
                       filter the exported products.
        with_deps: A `bool` indicating whether the dependencies for the targets
                   that are referenced by the products should be included
                   in the result.

    Returns:
        A list of the targets exported by the package.
    """
    targets_dict = dict([(p["name"], p) for p in pkg_desc["targets"]])
    products = _library_products(pkg_desc)
    if product_names != None:
        product_names_set = sets.make(product_names)
        products = [p for p in products if sets.contains(product_names_set, p["name"])]

    target_names = sets.make()

    # Collect the targets that are declared by the products.
    for product in products:
        for target_name in product["targets"]:
            sets.insert(target_names, target_name)

    # Collect the deps of the top-level targets
    if with_deps:
        target_names_to_collect = sets.to_list(target_names)
        for iteration in range(10):
            deps = _gather_deps_for_targets(targets_dict, target_names_to_collect)
            new_deps = sets.difference(deps, target_names)
            if sets.length(new_deps) == 0:
                break
            target_names_to_collect = sets.to_list(new_deps)
            target_names = sets.union(target_names, new_deps)

    return [targets_dict[target_name] for target_name in sets.to_list(target_names)]

def _is_library_target(target):
    """Returns True if the specified target is a library target. Otherwise False.

    Args:
        target: A target from the package description.

    Returns:
        A boolean indicating whether the target is a library target.
    """
    return target["type"] == "library"

def _library_targets(pkg_desc):
    """Returns a list of the library targets in the package.

    Args:
        pkg_desc: The dict returned from the `parse_package_descrition_json`.

    Returns:
        A list of the library targets in the package.
    """
    targets = pkg_desc["targets"]
    return [t for t in targets if _is_library_target(t)]

def _is_clang_target(target):
    """Returns True if the specified target is a clang module. Otherwise, False.

    Args:
        target: A target from the package description.

    Returns:
        A boolean indicating whether the target is a clang module.
    """
    return target["module_type"] == module_types.clang

def _is_swift_target(target):
    """Returns True if the specified target is a swift module. Otherwise, False.

    Args:
        target: A target from the package description.

    Returns:
        A boolean indicating whether the target is a swift module.
    """
    return target["module_type"] == module_types.swift

def _get_target(pkg_desc, name):
    """Returns the target with the specified name from a package description.

    Args:
        pkg_desc: A `dict` representing a package description.
        name: A `string` represneting the name of the desired target.

    Returns:
        A `dict` representing a target as represented in a package description.
    """
    for t in pkg_desc["targets"]:
        if t["name"] == name:
            return t
    fail("Could not find target with name %s." % (name))

# MARK: - Package Dependency Functions

def _dependency_repository_name(pkg_dep):
    """Returns the repository name from the provided dependency `dict`.

    Example:

    URL: https://github.com/swift-server/async-http-client.git
    Repository Name: async-http-client

    Args:
        pkg_dep: A `dict` representing a package dependency as defined in
                 a package description JSON.

    Returns:
        The repository name for the package dependency.
    """
    url = pkg_dep["url"]
    return packages.create_name(url)

def _dependency_name(pkg_dep):
    """Returns the name for the package dependency. 

    If a name was provided that value is returned. Otherwise, the repository
    name is returned.

    Args:
        pkg_dep: A `dict` representing a package dependency as defined in
                 a package description JSON.

    Returns:
        The name of the package dependency as a `string`.
    """
    name = pkg_dep.get("name", default = "")
    if name != "":
        return name
    return _dependency_repository_name(pkg_dep)

# MARK: - Namespace

module_types = struct(
    swift = "SwiftTarget",
    clang = "ClangTarget",
)

package_descriptions = struct(
    parse_json = _parse_json,
    get = _get_package_description,
    # Library Functions
    is_library_product = _is_library_product,
    library_products = _library_products,
    exported_library_targets = _exported_library_targets,
    # Target Functions
    is_library_target = _is_library_target,
    library_targets = _library_targets,
    is_clang_target = _is_clang_target,
    is_swift_target = _is_swift_target,
    get_target = _get_target,
    # Dependency Functions
    dependency_name = _dependency_name,
    dependency_repository_name = _dependency_repository_name,
    # Constants
    root_pkg_name = "_root",
)
